\chapter{Implementation}

\section{Version Control}
It took some time at the start of the project to get our version control (VC) methodology running smoothly. Members of the group were not familiar with using Git and it took them some time to understand its workflow, the required commands to use it and how to solve common issues like merge conflicts. \par
The second reason was that we were using two remote repositories: Visual Studio Online\cite{VSO} and Github\cite{Github}. Visual Studio Online was used for our team collaboration software, we could assign each other tasks, view burndown charts and create pull requests. It aided us in our project management. \par
Unfortunately there were a limited number of users who could view the code, therefore an additional repository was required for our client and manager. This meant that we had to set up our local repositories to push to both remotes and to never add anything to the projects via the online interfaces as this would cause the projects to come out of sync. This caused unease among some members of the group when using Git initially for fear of breaking the repositories which slowed down work to some extent. Getting all members sorted on using our chosen VC systems was part of the reason we decided to allow two weeks for the first sprint. \par
We had a lot of trouble early on with files being ignored that shouldn’t have been and vice versa. At first we had the nbproject folder excluded from Git, this included the build xml files for the JavaEE project. None of our projects would build and we realized that only the private folder within the nbproject folder should have been excluded. We had further issues in .NET with build files being included when they should have been ignored. .NET migration files also rendered after the solution project file (which couldn’t be excluded) and caused merge conflicts almost every time. \par
It was hard to figure out exactly what we should include in Git so that all of our projects would build correctly but also what to exclude so that we didn’t have clashing (for instance) build files when merging branches. We had this sorted after the first couple of weeks but it took time figuring out the best setup. 
\section{Initial Development, Database and User Authentication}
The work in sprint one was dedicated to getting the barebones system setup. Both .NET and JavaEE were scaffolded and integrated with a MySQL database. We felt that using a database first design would allow us to automatically generate a lot of code which would speed up the development of the system and using a common database structure and management system would help to ensure consistent features between the two projects. \par
The creation and integration of the database in both projects caused a bottleneck in the first sprint; other members could not get their work implemented on the system straight away as they had to wait for the database to be merged into the project. This could not be helped and was the other reason for a two week initial sprint. \par
We had a lot of problems with integrating .NET with the MySQL database. We found that although our database-first design was a good idea in principal, in reality when we came to implement features in the project we were having to make many unforeseen changes to the database structure. Migrating the .NET code to newer database versions was a lot simpler when using a code first approach as we could simply scrap the old database and regenerate a new one using our model classes. \par
Another issue was that the .NET Entity Framework required the database structure to be structured a specific way when applying user authentication. This caused problems when using MySQL server and simply would not work. To get around these issues we decided to change the DBMS in .NET from a MySQL Server to a Microsoft SQL Server (MSSQLS). MSSQLS integrated far more naturally with the .NET project than MySQL had. For instance updating the database was now a matter of adding a field to a model class and running a couple of commands. We no longer had to regenerate the model classes like we had using the database first approach. User Authentication now also worked. \par
A downside to this was that we effectively had to maintain two databases. The MySQL Server for JavaEE and MSSQLS for .NET. This led to extra work as we had to maintain the scripts for the MySQL Server and the models for MSSQL Server separately. It also did not promote consistency between the projects, we felt that this did not matter too much though as the under-the-hood mechanics of both projects did not have to match. \par
Setting up user authentication in JavaEE turned out to be an even bigger problem than a mere DBMS change. Glassfish realms was a nightmare to configure, especially concerning what specifically had to be added to the domain.xml file to get it working. The issue was largely down to a lack of comprehensive documentation. When examining the online documentation for JavaEE it can feel like reading in a language consisting purely of highly abstract conceptual metaphors, with very few concrete examples of how to actually go about achieving any of it within the scope of a project. This is contrary to the documentation in .NET which usually prioritises getting it working for a developer. \par
In addition to the already hard to understand documentation, Glassfish had been updated since the documents were written which meant that much of the example code that was on offer did not work. User authentication was eventually achieved, largely through trial and error and research outside of the JavaEE documentation. This did unfortunately eat up many hours of man power that could have been spent elsewhere if the documentation had been up to scratch.
\section{Fitbit and Jawbone}
\subsection{.NET}
We used the .NET OAuth library to authenticate user connections to the Fitbit server. We found that there were inconsistencies between the OAuth API implementation of OAuth 2.0 and Fitbit’s. Specifically when attempting to refresh tokens which the server consistently rejected. In an attempt to get it to work we wrote HTTP requests manually using the .NET HTTP libraries, building up the header and body ourselves as opposed to outsourcing that work to the OAuth API. Using this method we successfully got Fitbit refresh tokens accepted. \par
Jawbone had its own challenges. Although the OAuth API did work with Jawbone the documentation was extremely sparse and what documentation did exist was largely for OAuth 1.0. This caused time to be lost trying to figure out what information was required and what was relevant specifically for OAuth 2.0. \par
One observation about the two applications was that the OAuth API successfully sent Jawbone refresh tokens, this suggests that it was Fitbit’s refresh token implementation that was unordinary, not the API.
\subsection{JavaEE}
We used the OAuth Java (standard) library to try to authenticate with the two servers. For Jawbone this was much the same as with .NET. However, we could not authenticate with Fitbit. \par
When authenticating Fitbit requires an authentication field within the HTTP header. The value of this field is the word ‘Basic’ followed by the client ID and the client secret ID, separated with a colon and then encoded as a Base64 string. An example follows. \par
Authorization: Basic Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ= \par
The OAuth Java API couldn’t authenticate with the Fitbit server (unlike the .NET API) and when we tried to manually create the header by creating the string ourselves we still couldn’t get it authorized. The example above is the example Fitbit use on their website to allow developers to check they are using the correct encoding. We managed to reproduce that encoded string exactly, this proved that we were encoding the authentication header correctly, yet Fitbit still rejected all of our attempts with manual HTTP authentication in Java and .NET. \par
We finally decided that trying to get this to work was costing us too much of the little time we had so we were forced to abandon Fitbit in Java.
\section{Scheduling}
It was decided that we would be able to schedule jobs dynamically from the web interface. To be able to create scheduled jobs that could run on a user specified date and be either one time or recurring depending on their needs we used a scheduler service. 
\subsection{JavaEE}
In JavaEE we also had the option to use scheduled beans but we felt these were too restrictive for the project’s needs so we used the more advanced scheduling utility: ‘ExecutorService’, a class from the Java.Util.Concurrent package. The ExecutorService could take runnable Job objects and execute them at a given date, once or recurring. \par
In hindsight not using scheduled beans was likely an unwise decision as setting the service up was a lot of work, time could have been saved using the simpler scheduled beans. However, we were preparing for when we would want to use the scheduler to send out emails where this flexibility would be required. Unfortunately we did not end up implementing emails which meant that the added flexibility ended up being a nice but unnecessary feature that required a lot of work. .NET does not have a scheduler in its standard libraries so we were going to have to use a scheduler service for that application anyway, so it did at least allow the two programs to be better mirrors of each other. \par
An issue occurred setting up the Jawbone jobs with the scheduler. Much of the business code had been added to the WAR project. It was easier to add it here as the code could sit close to the controller classes which meant easy access, without having to worrying too much about calling EJB beans from outside the WAR. Unfortunately we found out why this is bad practice when trying to schedule jobs. \par
The Scheduler was implemented in the EJB project and whilst the WAR project had access to the EJB, the reverse was not true. This meant that the scheduler could not call business code relating to Jawbone and Fitbit as this code resided in the WAR project. It caused a lot of wasted time refactoring this code so that the business logic resided in the EJB project, allowing the scheduler to access it. If we had added our business logic to the EJB project initially time would have been saved. 
\subsection{.NET}
For .NET we had to look externally for an API that could handle this functionality for us. The two main competitors were the Quartz\cite{quartz} and Hangfire\cite{hangfire} API’s and due to the extensive documentation Hangfire was chosen.
Using Hangfire ended up causing some issues. It required a number of database tables, it was decided that we would use a separate database to store the Hangfire tables, in an attempt to minimise migration issues. The Entity Framework was used to create the Hangfire database automatically when the application was deployed if the database did not exist. Unfortunately if the database was deleted Visual Studio maintained a reference to it. It therefore believed the database did exist, didn’t create it and then fell over when it tried to access the Hangfire database. This could be solved by deleting the database server instance from the Visual Studio ‘Server Objects Explorer’ menu but caused some hassle when team members first deleted the database expecting it to be automatically recreated. \par
The other issue with Hangfire was that it expected all jobs to be idempotent. Whilst we assumed the Hangfire scheduler would run a job once at the given time, it would instead run it at the given time and then continually try to run it again every minute to make sure that the schedule had definitely run. This caused a lot of confusion when developing with Hangfire as we could not work out at first why our jobs were being executed so many times. 
\section{SOAP API}
Implementing the SOAP API didn’t cause too many issues. The web services could be scaffolded in both systems and then used like standard methods. Clients were created for both application web services and some basic authentication was added so that anonymous clients couldn’t add data on behalf of the GoAber users. \par 
Users could create an authentication token on the website, this would be stored against them in the database. When calling the SOAP API the authentication token would be required in the header. The database would then validate the token and find the user who owns that token. Standard users could add data only for themselves. Admin users could add data for any user.
\section{Challenges}
Implementing the cross-system side of challenges was tough. We first created a web service in .NET that could receive a challenge and result request. Then copied the .NET project to another location, opened and ran it. The primary .NET project could then import its own WSDL web service and we could write a client that could communicate with itself. The .NET project could then be run on two separate ports and the applications could send challenges to each other. \par
Challenges were added as a scheduled job, when the job completed a result request was sent to the other participating community server with details about how that host community had done in the challenge. The other community would receive the request, add the results data to its own database and send back its own results. Both communities now had each other’s results. Which could be displayed on their respective sites. \par
We created the JavaEE challenges web service by importing the WSDL from .NET. This meant that both systems used exactly the same WSDL file which made implementing the cross system challenges between .NET and JavaEE easier. The functionality of .NET was then mirrored in JavaEE by using the previously implemented scheduler service and copying/converting the code used in the .NET project for the web service and client to JavaEE. \par
The communities could now communicate challenges with each other. However, information about each client’s domains had to be pre-added to each database. To allow communities to add each other dynamically an extra web service method was added which could except details about a community, generate a unique ID for that community and add it to the database. The unique ID would then be sent back and challenges would be authorized using that ID. One community could now add another and both would be able to communicate with each other without having to add information about each community on both sides. A form to manage this was added in the community section of the website. \par
One issue we did have was that when Java was cleaned and built it would not add a reference to the challenges WSDL file to its WAR build files. When run, Glassfish would complain that it couldn’t find the WSDL until it was manually added by one of the developers. This was not a serious issue but was quite frustrating. \par
Another issue was that that information we wished to send across the servers was model data. I.e. we wanted to send a challenge model instance from one server to another. Due to the persistent nature of the model classes, specifically the ICollection foreign key type that most models implemented, the model classes themselves could not be sent via SOAP. Instead data transfer objects (DTO’s) had to be created for each model class we wanted to send. This was time consuming as code had to be written on each side to convert the models to DTO’s and then turn them back. \par
Whilst setting cross-system challenges up was very fiddly we didn’t have that many serious issues and after much testing we successfully implemented cross-system challenges.
\section{User Interface}
The standard JavaEE JSF web pages are scaffolded with a very basic CSS, unlike .NET. To make them look similar, we took the css scaffolded with .NET and applied it to our JavaEE project. \par
As we wanted to show Activity Data in a graph format for users we found a library to achieve this called D3.js\cite{D3.js}. D3.js required an AJAX request that returned JSON detailing what it was required to display. For .NET, this was easy to set up as controllers could be changed to output JSON data as opposed to an HTML view. In JavaEE, this was a lot harder as a controller class cannot return JSON. We managed to implement this functionality in JavaEE using the JAX RS\cite{JAXRS} library, with it we created a second servlet which purely handled AJAX JSON requests via rest-service classes. \par
To try to further improve the look of the JavaEE web pages, we used a library named PrimeFaces. PrimeFaces improved the look of form UI components. One issue that we did find with PrimeFaces was that date filtering did not work out of the box. We wanted activity data to be able to be filtered by the creation date of the data and it took some wrestling with PrimeFaces to get this working. The problem was largely down to a lack of decent documentation. A trend we found with many of the technologies we used.
\section{Internationalization}
There were very few problems with implementing internationalization on either application. JavaEE implemented this functionality almost automatically. With a small change to our faces-config.xml file we had it working. This was an element was really liked about JavaEE, when scaffolding classes, strings were automatically added to a bundle class. We could then replicate these strings over to the Welsh version of the bundle. \par
On the other hand, .NET did not implement internationalization automatically. Neither did it add the strings to any bundle-like class. A resources project was created, resource files were added containing the strings for the English and Welsh versions. We then had to manually go through the site and replace hard-coded strings with their resource file versions. Lastly, by following an online tutorial\cite{mvci18ntutorial} we added a controller super class which changed the language for a user using a cookie. \par
Although more work was required for .NET it still wasn’t particularly technically challenging. Although, replacing all strings was very time consuming and required continual work throughout the project.
\section {General Issues}
Throughout the project we experienced some issues not specific to any one feature. \par
JavaEE had a habit of caching data. This caused issues, especially when testing newly implemented features. We would try to add data, the data then would not appear in the user interface until we refreshed the page several times or logged out and back in. We managed to turn caching off in the JavaEE project files and then switch it off manually per Java bean. \par
Debugging the projects was very slow, especially in JavaEE. The systems took a long time to fire up and sometimes a developer could run them, see a bug, fix the bug, re-run the application, notice either another bug or the same bug still not fixed and have to continually repeat the process. This added huge amounts of time when developing the project. \par
Glassfish was extremely temperamental. It did not seem to build the project properly when we ran it. Often errors would occur during deployment but by cleaning and rebuilding the project they would be magically fixed. Glassfish also does not display error messages well, it outputs stack traces to the console but they are usually hard to read and figure out. On the other hand, .NET outputs errors in a clearer format. If certain exceptions are thrown, it will automatically stop the project and put the developer into debug mode. Lastly, it will usually show hints if an error appears when trying to load a page. For instance, when the database uses an old migration, .NET informs the developer that they may need to upgrade to a newer version of the database. This saves a lot of time.

